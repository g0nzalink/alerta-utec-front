import type { Comment } from '../types';
import { AppError } from '../utils/helpers';
import axios, { type AxiosInstance } from 'axios';
import { TOKEN_KEY } from '../config';

// Interfaces para el backend de comentarios
interface BackendCommentRequest {
  comment: string;
  userId: string;
  userName: string;
}

interface BackendCommentResponse {
  commentId: string;
  incidentId: string;
  comment: string;
  userId: string;
  userName: string;
  createdAt: number;
}

interface BackendCommentsListResponse {
  comments: BackendCommentResponse[];
  count: number;
}

// URL base para la API de incidentes (los comentarios est√°n bajo incidents)
const INCIDENTS_BASE_URL = 'https://wkcu4ednn9.execute-api.us-east-1.amazonaws.com/prod';

// Cliente HTTP espec√≠fico para comentarios con autenticaci√≥n
const commentsHttpClient: AxiosInstance = axios.create({
  baseURL: INCIDENTS_BASE_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
});

// Interceptor para agregar el token de autenticaci√≥n
commentsHttpClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem(TOKEN_KEY);
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    console.log('üöÄ Comments API Request:', {
      method: config.method?.toUpperCase(),
      url: config.url,
      headers: config.headers,
      data: config.data,
    });
    return config;
  },
  (error) => {
    console.error('‚ùå Comments Request Error:', error);
    return Promise.reject(error);
  }
);

// Interceptor para manejar respuestas
commentsHttpClient.interceptors.response.use(
  (response) => {
    console.log('‚úÖ Comments API Response:', {
      status: response.status,
      url: response.config.url,
      data: response.data,
    });
    return response;
  },
  (error) => {
    console.error('‚ùå Comments Response Error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

class CommentsAPI {
  private convertBackendToFrontend(backend: BackendCommentResponse): Comment {
    return {
      id: backend.commentId,
      incidentId: backend.incidentId,
      content: backend.comment,
      createdAt: new Date(backend.createdAt * 1000).toISOString(),
      createdBy: backend.userId,
      createdByName: backend.userName,
    };
  }

  async getComments(incidentId: string): Promise<Comment[]> {
    try {
      console.log('üîó Fetching comments for incident:', incidentId);
      
      // El backend NO tiene endpoint /incidents/{id}/comments
      // Los comentarios est√°n en la misma tabla con type: 'comment'
      // Usar directamente el m√©todo que funciona
      return await this.getCommentsFromIncidentsEndpoint(incidentId);
      
    } catch (error: any) {
      console.error('‚ùå Get comments error:', error);
      
      throw new AppError(
        error.response?.data?.message || error.message || 'Error al obtener comentarios',
        error.response?.status || 500
      );
    }
  }

  // Fallback method to get comments from the main incidents endpoint
  private async getCommentsFromIncidentsEndpoint(incidentId: string): Promise<Comment[]> {
    try {
      console.log('üîÑ Trying fallback: getting comments from incidents endpoint');
      
      // Import the incidents HTTP client
      const { incidentsHttpClient } = await import('../services/httpClient');
      
      const response = await incidentsHttpClient.get('/incidents');
      
      // Handle different response structures
      let allItems = Array.isArray(response.data) ? response.data : 
                     response.data.items ? response.data.items : 
                     response.data.incidents ? response.data.incidents : [];
      
      // Filter comments for this specific incident
      const commentsForIncident = allItems.filter(item => 
        item.type === 'comment' && 
        item.parentIncidentId === incidentId
      );
      
      console.log(`üìã Found ${commentsForIncident.length} comments for incident ${incidentId} via fallback`);
      
      // Convert to frontend format
      const comments = commentsForIncident.map(comment => ({
        id: comment.commentId,
        incidentId: comment.parentIncidentId,
        content: comment.comment,
        createdAt: new Date(comment.createdAt * 1000).toISOString(),
        createdBy: comment.userId,
        createdByName: comment.userName,
      }));
      
      // Sort by creation date (oldest first)
      comments.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
      
      return comments;
    } catch (error) {
      console.error('‚ùå Fallback method also failed:', error);
      return [];
    }
  }

  async createComment(incidentId: string, content: string, user?: { id: string; name: string }): Promise<Comment> {
    try {
      // Validate comment content first
      this.validateComment(content);
      
      // Get user info from localStorage if not provided
      let userId = 'anon';
      let userName = 'An√≥nimo';
      
      if (user) {
        userId = user.id;
        userName = user.name;
      } else {
        // Try to get from stored user data
        try {
          const userDataString = localStorage.getItem('user_data');
          if (userDataString) {
            const userData = JSON.parse(userDataString);
            userId = userData.email || userData.userId || 'anon';
            userName = userData.full_name || userData.nombre || 'Usuario';
          }
        } catch (e) {
          console.warn('Could not get user data from localStorage');
        }
      }

      const backendData: BackendCommentRequest = {
        comment: content.trim(),
        userId: userId,
        userName: userName,
      };

      console.log('üîó Creating comment:', backendData);
      const response = await commentsHttpClient.post<BackendCommentResponse>(`/incidents/${incidentId}/comments`, backendData);
      
      console.log('‚úÖ Comment created:', response.data);
      return this.convertBackendToFrontend(response.data);
    } catch (error: any) {
      console.error('‚ùå Create comment error:', error);
      throw new AppError(
        error.message || 'Error al crear el comentario',
        error.status || 500
      );
    }
  }

  async deleteComment(incidentId: string, commentId: string): Promise<void> {
    try {
      console.log('üîó Deleting comment:', commentId);
      await commentsHttpClient.delete(`/incidents/${incidentId}/comments/${commentId}`);
      console.log('‚úÖ Comment deleted:', commentId);
    } catch (error: any) {
      console.error('‚ùå Delete comment error:', error);
      throw new AppError(
        error.message || 'Error al eliminar el comentario',
        error.status || 500
      );
    }
  }

  // M√©todo para validar comentarios
  private validateComment(content: string): void {
    if (!content || content.trim().length < 3) {
      throw new AppError('El comentario debe tener al menos 3 caracteres', 400);
    }
    
    if (content.trim().length > 1000) {
      throw new AppError('El comentario no puede exceder 1000 caracteres', 400);
    }
  }
}

export const commentsAPI = new CommentsAPI();
